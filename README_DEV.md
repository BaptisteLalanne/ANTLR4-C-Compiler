# PLD-Compilateur
[![CI PLD Compilateur](https://github.com/BaptisteLalanne/PLD-Compilateur/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/BaptisteLalanne/PLD-Compilateur/actions/workflows/ci.yml)

## Description

This documention is intended for developers who wants to maintain the project. If you simply want to use our compiler, go check our [user documentation](https://github.com/BaptisteLalanne/PLD-Compilateur/README.md)

## Architecture

Here is our source code tree:

```
.
├── antlr
├── compiler
│   └── IR
└── tests
    ├── ifcc-test-output
    |   └── ...
    └── testfiles
```

`antlr` directory is included in thi repo to avoid conflicts with ANTLR4 version, from one computer to another. With this static import, development gets easier.

### Compiler folder

In the `compiler` folder, you will find our C++ source code, our grammar, and also our Makefile.

Files in `compiler` folder:
- `ifcc.g4`: our grammar, which will be analyzed by ANTLR4 library,
- `runner.sh`: a bash script to compile and run a c-like file with our compiler. Usage: `./runner.sh my_program.c`,
- `Makefile`: makefile to compile our source code (see "Build" section in our [user documentation](https://github.com/BaptisteLalanne/PLD-Compilateur/README.md)),
- `main.cpp`: contains main function, which launch the lexer to analyze syntax, then our visitors to generate IR, and then write assembly using those IR instructions,
- `CodeGenVisitor.*` : all our visitors, one for each expression defined in our grammar,
- `ErrorHandler.*` : a simple error logger class.

A `IR` subfolder also contains source code:
- `Instr.*` : all the instructions (`copy`, `ldconst`, `op_add`...) that can be put in our intermediate representation,
- `BasicBlock.*` : basic block codes, which contains IR instructions and run them one after another to generate assembly code,
- `CFG.*` : the control flow graph code, which manages all the basic blocks of the user c-like program.


### Tests folder

All the tests (c-like program) must be put in `testfiles` subdirectory. Python script `ifcc-test.py` allows you to run all the tests or simply one.

```sh
$ python3 ifcc-test.py testfiles # to run all the tests
$ python3 ifcc-test.py testfiles/my_test_file.c # to run only one test
```

After execution, a `ifcc-test-output` folder is generated. In it, others subfolders are generated for each test executed. For exemple:

```
└── tests
    ├── ifcc-test-output
    │   ├── testfiles-01_01_00_return42
    │   ├── testfiles-01_02_00_invalid_program
    │   ├── testfiles-01_03_00_multiline_comment_valid
    │   └── ...
    └── testfiles
```

In each `test_files-*` subdirectory, you will find:
- `asm-gcc.s` : assembly code generated by gcc,
- `asm-ifcc.s` : assembly code generated by our compiler,
- `exe-gcc` : binary generated by gcc,
- `gcc-compile.txt` : compilation message written by gcc,
- `gcc-execute.txt` : execution message written by gcc,
- `gcc-link.txt` : link message written by gcc,
- `ifcc-compile.txt` : link message written by our compiler,
- `ifcc-execute.txt` : execution message written by our compiler,
- `ifcc-link.txt` : link message written by our compiler,
- `input.c` : c-like program tested.

Our python script compare if results (`*-compile.txt`, `*-link.txt` and `*-execute.txt`) are the same with GCC and IFCC (our compiler).